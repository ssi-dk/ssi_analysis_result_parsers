# Global static vars


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

For help with the Markdown language, see [this
guide](https://www.markdownguide.org/basic-syntax/).

# Dev mode

If you’re developing this versus running this, you’ll have access to
slightly different things. Notable the nbdev functions are only for
development and not for runtime. This matters for items such as the
config. So we need to detect if you are in dev mode or not and the code
has to adjust accordingly. Notice that this section is not exported so
will only work in the notebook and not in the module.

``` python
# This section uses nbdev functions so should not be exported as it's for dev purposes
import os

if DEV_MODE:
    PACKAGE_DIR = nbdev.config.get_config(cfg_name="settings.ini", path=os.getcwd())[
        "lib_path"
    ]  # the library is the package of course
    PROJECT_DIR = nbdev.config.get_config(
        cfg_name="settings.ini", path=os.getcwd()
    ).config_path  # the default location of nbdev config file (settings.ini)
```

# Core

A module which contains common functions to be used by other modules.
Those that exist in the template are meant to be common functions we can
use against multiple packages.

## Libraries

Currently all libraries included are listed at the top and calls to them
are also made in the block of code that uses them. This is for
readability and the performance hit of the import is negligible.

## Config

Our config file holds all program and user specific variables. This is a
good practice to follow as it allows us to easily change variables
without having to change code. It also allows us to easily change
variables based on the environment we are running in. For example, we
may want to run a program in a test environment with a different
database than we would in production. This is also a good practice to
follow as it allows us to easily change variables without having to
change code. It also allows us to easily change variables based on the
environment we are running in. For example, we may want to run a program
in a test environment with a different database than we would in
production.

Configuration is templated to rely on environment (ENV) variables. A
default ENV config is provided in `./config/config.default.env` and more
advanced data structures are supported in
`./config/config.default.yaml`. The `.yaml` file is meant to represent
what your program actually works with and the `.env` file options the
user can change at run time.

Make sure you know the priority of variables and check on them when
debugging your code. Also ensure that your yaml file is referenced
appropriately in the `.env` file.

When in use there’s an expectation you’ll have multiple config files for
different use cases e.g. development, production environment for
different paths, etc.

### set env variables

A helper function for getting your config values, this will set the
environment variables with the provided `.env` values. If you’re missing
values it’ll ensure they’re loaded in with the defaults file.

------------------------------------------------------------------------

<a
href="https://github.com/thej-ssi/ssi_analysis_result_parsers/blob/main/ssi_analysis_result_parsers/core.py#L65"
target="_blank" style="float:right; font-size:smaller">source</a>

### set_env_variables

>  set_env_variables (config_path:str, overide_env_vars:bool=True)

### get config

When you run this function, assuming things are set up properly, you end
up with a dict that matches your `.yaml` file. This file will have all
the inputs for the package and settings of your program.

To do this it will use a `.env` config file, which has an associated
yaml file defined with `CORE_YAML_CONFIG_FILE` in the `.env` file. And
then use the `.env` file to load values into the associated `.yaml`
file.

------------------------------------------------------------------------

<a
href="https://github.com/thej-ssi/ssi_analysis_result_parsers/blob/main/ssi_analysis_result_parsers/core.py#L92"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_config

>  get_config (config_path:str=None, overide_env_vars:bool=True)

### Variables

All the user input variables and machine adjustable variables should be
in your config, which is a dict. Reference config.default.yaml for how
to access your variables. Also note that with python dicts you can use
`dict_variable.get("variable", default_value)` to ensure that you don’t
get a key error if the variable is not set.

### show project env vars

A helper function intended to only be used with debugging. It shows all
your project specific environmental variables.

------------------------------------------------------------------------

<a
href="https://github.com/thej-ssi/ssi_analysis_result_parsers/blob/main/ssi_analysis_result_parsers/core.py#L113"
target="_blank" style="float:right; font-size:smaller">source</a>

### show_project_env_vars

>  show_project_env_vars (config:dict)

## get_samplesheet

This function is to unify the way we work with sample_sheet’s which is
for us a file with a table of values, typically samples for batch
processing. We want to approach doing it this way so all programs have
batch processing in mind and working with the same data structure.

To make use of it we have a small sample_sheet yaml object which looks
like

``` yaml
sample_sheet:
    path: path/to/sample_sheet.tsv
    delimiter: '\t' # Optional, will assume , for csv and \t otherwises
    header: 0 # Optional, 0 indicates first row is header, None indicates no header
    columns: ['column1', 'column2', 'column3'] # Optional, if not provided all columns will be used
```

Make sure to add that to your relevant section in your config (can be
multiple times if you’re working with different sheets or different
columns), then call the function on this object and it’ll either mention
somethings wrong or return a pandas dataframe with the columns of
interest.

This is an example of a common sample_sheet we work with. We will ingest
the hash at the beginning so it doesn’t affect column naming. Extra
empty rows at the end are also stripped.

``` tsv
#sample_id  file_path   metadata1   metadata2
Sample1 /path/to/sample1.fasta  value1  option1
Sample2 /path/to/sample2.fasta  value2  option2
Sample3 /path/to/sample3.fasta  value3  option1
Sample4 /path/to/sample4.fasta  value1  option2
Sample5 /path/to/sample5.fasta  value2  option1
```

``` python
# This block should never be exported. It is to have python running in the project (and not the nbs) dir, and to initiate the package using pip.
os.chdir(PROJECT_DIR)
```

------------------------------------------------------------------------

<a
href="https://github.com/thej-ssi/ssi_analysis_result_parsers/blob/main/ssi_analysis_result_parsers/core.py#L125"
target="_blank" style="float:right; font-size:smaller">source</a>

### get_samplesheet

>  get_samplesheet (sample_sheet_config:dict)

------------------------------------------------------------------------

<a
href="https://github.com/thej-ssi/ssi_analysis_result_parsers/blob/main/ssi_analysis_result_parsers/core.py#L293"
target="_blank" style="float:right; font-size:smaller">source</a>

### print_results_dict_to_tsv

>  print_results_dict_to_tsv (results_dict:dict, output_file:pathlib.Path,
>                                 sample_name:str=None)

------------------------------------------------------------------------

<a
href="https://github.com/thej-ssi/ssi_analysis_result_parsers/blob/main/ssi_analysis_result_parsers/core.py#L244"
target="_blank" style="float:right; font-size:smaller">source</a>

### update_results_dict

>  update_results_dict (old_results:dict, new_results:dict,
>                           old_duplicate_key_prefix:str=None,
>                           new_duplicate_key_prefix:str=None)

------------------------------------------------------------------------

<a
href="https://github.com/thej-ssi/ssi_analysis_result_parsers/blob/main/ssi_analysis_result_parsers/core.py#L196"
target="_blank" style="float:right; font-size:smaller">source</a>

### PipelineResults

>  PipelineResults (results_dict)

*Initialize self. See help(type(self)) for accurate signature.*

``` python
### Make sure results dict are updated properly
assert(update_results_dict({"a": 1, "b": 2}, {"b":5,"c":7}, new_duplicate_key_prefix="new: ")["new: b"] == 5)
assert(update_results_dict({"a": 1, "b": 2}, {"b":5,"c":7}, old_duplicate_key_prefix="old: ")["old: b"] == 2)
assert(update_results_dict({"a": 1, "b": 2}, {"b":5,"c":7}, new_duplicate_key_prefix="new: ", old_duplicate_key_prefix="old: ")["a"] == 1)
assert(update_results_dict({"a": 1, "b": 2}, {"b":5,"c":7}, new_duplicate_key_prefix="new: ", old_duplicate_key_prefix="old: ")["new: b"] == 5)
assert(update_results_dict({"a": 1, "b": 2}, {"b":5,"c":7}, new_duplicate_key_prefix="new: ", old_duplicate_key_prefix="old: ")["old: b"] == 2)



### Make sure results dicts are printed correctly to file
print_dict = update_results_dict({"a": "1", "b": "2"}, {"b": "5","c": "7"}, new_duplicate_key_prefix="new: ")


test_output_path = "./test_output/output.tsv"
print_results_dict_to_tsv(print_dict, test_output_path)
h256 = sha256()
h256.update(open(test_output_path,"rb").read())
assert(h256.hexdigest() == "95010ad49667c28a25bb80bb450290e5f7286c7eeb3220ff795c9fecf1326ce1")
os.remove("./test_output/output.tsv")



test_output_path = "./test_output/output_with_sample_name.tsv"
print_results_dict_to_tsv(print_dict, "./test_output/output_with_sample_name.tsv", "sample1")
h256 = sha256()
h256.update(open(test_output_path,"rb").read())
assert(h256.hexdigest() == "3501bb59ac5ccee5820ac5f66bd314c42098a5bb808abcfd830d3c38b744754a")
```
